# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Медведев Н.А

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки в прологе отличаются тем , что являются неизменяемыми структурами данных, более того они имеют рекурсивную структуру ,cписки в прологе похожи на связные списки, которые используются в традиционных языках программирования.

## Задание 1.1: Предикат обработки списка

`tail_separator_(List, Value, Result).` - этот предикат отделяет хвост, начиная с элемента с данным значением

Примеры использования:
```prolog
?- tail_separator([1, 2, 3, 4, 6], 3, Result).
Result=[4,6]
?- tail_separator([2, 1, 3, 4, 6], 2, Result).
Result=[3,4,6].
```

Реализация:
```prolog
tail_separator_(List, Value, Result) :- 
    append(_, [Value|Result], List).
...
```

В  реализации используется предикат append, который объединяет части списка.
`tail_separator_my([], _, []).` - этот предикат отделяет хвост, начиная с элемента с данным значением

Примеры использования:
```prolog
?- tail_separator_my([1, 25, 32, 7, 6], 3, Result).
Result=[7,6]
?- tail_separator_my([3, 10, 5, 4, 6], 2, Result).
Result=[5,4,6].
```

Реализация:
```prolog
tail_separator_my([H|T], Value, Result) :-
    H \= Value,
    tail_separator_my(T, Value, Result).
tail_separator_my([Value|T], Value, T).
...
```
во второй реализации мы явно проверяем значения элементов и рекурсивно собираем хвост списка.

## Задание 1.2: Предикат обработки числового списка
`list_product(List, Product).` - этот предикат вычисляет произведение всех элементов списка
Примеры использования:
```prolog
?-list_product([2, 3, 4], Product). 
Product = 24.
?-list_product([1, 2, 3, 5], Product). 
Product = 30.
```

Реализация:
```prolog
list_product(List, Product) :-
    product_list(List, 1, Product).

product_list([], Product, Product).
product_list([H|T], Accumulator, Product) :-
    NewAccumulator is Accumulator * H,
    product_list(T, NewAccumulator, Product).
...
```
предикат  вычисляет произведение всех элементов списка. В  реализации мы используем предикат product_list, который рекурсивно перемножает элементы списка, передавая Accumulator, который хранит текущее произведение. 
`list_product_my([], 1).` - этот предикат вычисляет произведение всех элементов списка
Примеры использования:
```prolog
?-list_product_my([2, 3, 4, 5], Product). 
Product = 120.
?-list_product_my([1, 2, 3, 5], Product). 
Product = 30.
```

Реализация:
```prolog
list_product_my([], 1).
list_product_my([H|T], Product) :-
    list_product_my(T, RestProduct),
    Product is H * RestProduct.
...
```
предикат  вычисляет произведение всех элементов списка. Во второй реализации мы также используем рекурсию, но без использования дополнительного предиката,как в предыдущем примере .
## Задание 2: Реляционное представление данных

Преимущества реляционного представления в целом:

1. Декларативность: Реляционное представление позволяет описывать отношения между данными в виде предикатов. Это позволяет выражать логику и отношения между данными на более высоком уровне абстракции, что делает код более понятным и легко поддерживаемым.

2. Гибкость: Реляционное представление позволяет работать с неструктурированными данными и изменять структуру данных без необходимости изменения кода. Это делает реляционное представление более гибким и адаптивным к изменениям в данных.

3. Универсальность: Реляционное представление позволяет описывать и решать различные типы задач, включая поиск, фильтрацию, сортировку, связывание и другие операции над данными. Это делает реляционное представление универсальным инструментом для работы с данными.

Недостатки реляционного представления на языке Пролог:

1. Эффективность: Реляционное представление в Прологе может быть неэффективным для больших объемов данных или сложных запросов. 
2. Ограничения языка: Язык Пролог имеет свои ограничения и специфику.
3. Сложность понимания: Реляционное представление данных в Прологе может быть сложным для понимания и использования для программистов, не знакомых с логическим программированием. 

В конкретном представлении one.pl  данные о студентах, предметах и оценках представлены в виде фактов и правил, которые описывают отношения между ними. Это позволяет легко и естественно выполнять запросы и операции над данными, такие как поиск оценок студента, фильтрация по предметам и т.д. 

Предикат average_grade(Group, Average) вычисляет средний балл для студентов определенной группы. 

Принцип реализации:
1. Проверяем, что группа существует, используя предикат student(Group, _), чтобы получить список студентов этой группы.
2. Используем предикат findall(Grade, grade(_, _, Grade), Grades) для поиска всех оценок из базы данных и сохраняем их в списке Grades.
3. Вычисляем количество оценок, используя предикат length(Grades, NumGrades).
4. Суммируем все оценки, используя предикат sum_list(Grades, Sum).
5. Вычисляем средний балл, разделив сумму оценок на количество оценок: Average is Sum / NumGrades.

Предикат num_students_failed_exam(Group, NumStudents) находит количество студентов, не сдавших экзамен в определенной группе.

Принцип реализации:
1. Проверяем, что группа существует, используя предикат student(Group, _), чтобы получить список студентов этой группы.
2. Используем предикат findall(Student, (student(Group, Student), grade(Student, _, 2)), FailedStudents) для поиска студентов, которые получили оценку 2 (не сдали экзамен).
3. Вычисляем количество несдавших студентов, используя предикат length(FailedStudents, NumStudents).

Предикат students_failed_exam(Subject, Students) находит студентов, не сдавших определенный предмет.

Принцип реализации:
1. Проверяем, что предмет существует, используя предикат subject(Subject, _), чтобы получить список студентов, связанных с этим предметом.
2. Используем предикат findall(Student, (student(_, Student), \+ grade(Student, Subject, 2)), Students) для поиска студентов, которые не получили оценку 2 (не сдали предмет).
3. Сохраняем найденных студентов в списке Students.

## Выводы
В результате выполнения лабораторной работы я ознакомился с языком программирования Prolog и его основными конструкциями. Я реализовал предикаты для обработки числовых и символьных списков, а также осуществил запросы к реляционному представлению данных о студентах, группах и оценках.

Основные выводы:
1. Язык программирования Prolog позволяет организовать представление данных в виде реляционных таблиц, что удобно для работы в различных областях.
2. Использование предикатов findall, bagof и setof позволяет совершать запросы к данным и получать списки решений для заданных условий.
3. Реализация предикатов для обработки списков позволяет проводить различные операции, такие как вычисление средних значений, подсчет количества элементов, фильтрация и т.д.
4. Реляционное представление данных позволяет легко выполнять запросы и получать информацию о студентах, группах и их оценках.

В целом, выполнение данной лабораторной работы позволило мне приобрести начальные навыки работы с языком Prolog и ознакомиться с его возможностями в обработке данных и формулировке запросов.

